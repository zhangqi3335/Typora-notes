## 1. 指针数组和数组指针

### 1.1 什么是指针数组和数组指针

- 指针数组：指针数组可以说成是“指针的数组”，首先这个变量是一个**数组**，其次，“指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型。

  [^在32位系统中，指针占四个字节，在64位系统中，所有指针的大小都是8字节]: 

- 数组指针：数组指针可以说成是“数组的指针”，首先这个变量是一个**指针**，其次，“数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。
- 两者是两种类型的变量。

### 1.2 指针数组和数组指针的详解

#### 1.2.1 指针数组

定义一个指针**数组**，因为是数组，名字就叫arr。

```
char *arr[4] = {"zhi","zhen","shu","zu"};
//arr就是一个指针数组，它有四个元素，每个元素都是一个char *类型的指针，这些指针存放着对应字符串的首地址。
```

```c
#include <stdio.h>

int main() {
   
    char *arr[4] = {"zhi", "zhen", "shu", "zu"};
    printf("指针数组的第一个的值：%p\n", arr[0]);
    printf("指针数组的第一个的指向的地址的值：%s\n", arr[0]);
    printf("%c\n", *(p_arr[1] + 1));
    return 0;
}

```

输出:

```
指针数组的第一个的值：0000000000404000 //数组中包含的是指针
指针数组的第一个的指向的地址的值：zhi    //指针指向的内容才是“zhi”
e                                 //p_arr[1]指向"def"，+1指向'd'的下一个字符'e'
```

这个指针数组在64位系统中有4*8 = 32字节，因为一个指针为8个字节

当有对变量所占空间有疑惑时，要反应出**内存映像图**

| 内存映像像图            | 核心属性（读写/权限）          | 存储内容                                                     | 关键特征                                                     |
| ----------------------- | ------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 命令行参数 / 环境变量区 | 只读（环境变量）/ 可读（参数） | `main` 函数的 `argc`/`argv`（命令行参数）、环境变量（如 `PATH`） | 位于栈区上方、程序启动时由操作系统传入、只读属性（部分系统可修改） |
| 栈区（Stack）           | 可读可写                       | 函数局部变量（如 `int a = 5;`）、函数参数、返回值、栈帧信息（保存上下文） | 自动管理（函数调用时压栈、返回时弹栈）、大小固定（超出会栈溢出）、地址从高向低增长 |
| 堆区（Heap）            | 可读可写                       | 动态分配的内存（`malloc`/`calloc`/`realloc` 分配的空间、C++ 中 `new` 分配的空间） | 大小动态变化（运行时申请 / 释放）、由程序员手动管理（漏释放会内存泄漏）、地址从低向高增长 |
| BSS 段（.bss）          | 可读可写                       | 未初始化的全局变量（如 `int g_uninit;`）、未初始化的静态变量（如 `static int s_uninit;`） | 编译时仅分配地址（不占磁盘空间）、程序启动时由操作系统清零、大小运行前确定 |
| 数据段（.data）         | 可读可写                       | 已初始化的全局变量（如 `int g_val = 10;`）、已初始化的静态变量（如 `static int s_val = 20;`） | 编译时确定大小、程序启动时由操作系统加载初始化值、生命周期贯穿整个程序 |
| 只读数据段（.rodata）   | 只读（不可写）                 | 字符串字面量（如 `"hello"`）、`const` 修饰的全局 / 静态只读变量、字面常量（如 `3.14`） | 编译时确定大小、不可修改（强行写会触发段错误）、有时被归为代码段附属 |
| 代码段（.text）         | 只读（不可写）                 | 编译后的机器指令（函数体代码、流程控制指令等）               | 固定大小（编译时确定）、共享（多个进程可共享同一份代码）、高地址起始 |

- **堆和栈的增长方向**：多数系统中，栈从高地址向低地址 “向下增长”，堆从低地址向高地址 “向上增长”，两者之间有空闲区域（避免冲突）。
- **const 变量的特殊情况**：`const` 修饰的局部变量（如 `void func() { const int a = 1; }`）实际存在栈区（只是编译时禁止修改），只有全局 / 静态 `const` 变量才在 `.rodata` 段。

#### 1.2.2 数组指针

定义一个数组**指针**，变量是指针，就叫做p_arr

```
char (*p_arr)[4];
```

Q:既然p_arr是一个指针，存放一个数组的地址，那么在我们定义一个数组时，数组名称就是这个数组的首地址，那么这二者有什么区别呢？能相互赋值吗？

A：例如`char a[4]; `,a是一个长度为4的字符数组，a是**“数组类型标识符”，在表达式中隐式转换为数组的首元素的地址**。既然a是地址，p_arr是**指向整个数组的指针**，不能互相赋值，因为a是**数组首元素**首地址，p_arr存放的是**数组**首地址，a是char类型，`a+1`,a的值会加一，而p_arr是char[4]类型的，`p_arr+1`，p_arr则会加4，两者操作不同，类型不匹配不能直接赋值。

```c
#include <stdio.h>

int main() {
   
    char a[4];
    char *p_elem = a;
    char (*p_whole_arr)[4] = &a;
	/*
	p_whole_arr = a;        // 编译报错！a隐式转char*，和p_whole_arr的char(*)[4]类型不匹配
	p_whole_arr = &a;       // 合法！&a是“整个数组的地址”，类型正是char(*)[4]，直接匹配
	*/
    
    printf("a的地址：%p\n", a);      // 首元素地址
    printf("a+1的地址：%p\n", a+1);  // 偏移1字节，char类型大小是1
    printf("p_elem+1：%p\n", p_elem+1);  // 和a+1完全一致
    printf("\n");
   
    printf("&a的地址：%p\n", &a);        // 数值还是和a的数值相同
    printf("p_whole_arr+1：%p\n", p_whole_arr+1);  // 输出偏移4字节，数组类型大小是4
    return 0;
}
```

输出：

```
a的地址：000000000061FE0C
a+1的地址：000000000061FE0D
p_elem+1：000000000061FE0D

&a的地址：000000000061FE0C
p_whole_arr+1：000000000061FE10
```

### 1.3 指针数组和数组指针的使用

#### 1.3.1 指针数组的使用

指针数组是「**管理多个字符串**」的最优方案（比二维字符数组`char arr[4][5]`更灵活、省空间），核心用法如下：

```
// 冒泡排序：按字符串字典序排序（升序）
void sort_strings(char *p_arr[], int n) {
    char *tmp;
    for (int i = 0; i < n-1; i++) {
        for (int j = 0; j < n-1-i; j++) {
            // strcmp比较两个指针指向的字符串内容
            if (strcmp(p_arr[j], p_arr[j+1]) > 0) {
                // 交换指针（仅8字节，比拷贝字符串快得多）
                tmp = p_arr[j];
                p_arr[j] = p_arr[j+1];
                p_arr[j+1] = tmp;
            }
        }
    }
}
```

在排序时无需拷贝字符串内容（仅交换指针），效率较高（尤其字符串比较长的时候）。

#### 1.3.2 数组指针的使用

数组指针专门用于「**指向完整数组**」，而非单个元素，字符场景下用得较少（多在二维数组传参、操作固定长度字符数组时使用）。

二维数组传参时，数组名会隐转为「指向一维数组的指针」（即数组指针），用数组指针接收能明确数组维度，更严谨

### 1.4 巩固理解

1.以下代码输出什么？为什么？

```c
char *p_arr[] = {"abc", "def", "ghi"};
printf("%c\n", *(p_arr[1] + 1)); // 输出 'e'（p_arr[1]指向"def"，+1指向'd'的下一个字符'e'）
```

2.以下代码编译报错吗？为什么？

```c
char arr[5] = "test";
char (*arr_p)[5] = arr; // 报错！arr隐转为char*，与arr_p的char(*)[5]类型不匹配，需改为&arr
```

3.字符指针数组和二维字符数组（`char arr[3][5]`）的区别？

- 字符指针数组：元素是指针，指向的字符串长度可不同，省空间，排序高效；
- 二维字符数组：元素是字符，每行长度固定，浪费空间，排序需拷贝字符内容。
