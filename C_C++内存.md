## C 语言中内存分配的方式有几种？

C 语言的内存分配方式主要有 3 种：

1. **静态存储区分配**：内存分配在程序编译之前完成，且在程序的整个运行期间都存在，例如全局变量、静态变量等。
2. **栈上分配**：在函数执行时，函数内的局部变量的存储单元在栈上创建，函数执行结束时这些存储单元自动释放。
3. **堆上分配**。

### 内存分配方式对比表

| 序号 | 分配方式       | 特点和用途                                                   |
| ---- | -------------- | ------------------------------------------------------------ |
| 1    | 静态存储区分配 | - 分配时机：在程序编译时完成分配- 生存周期：程序运行期间始终存在- 典型用途：全局变量、静态变量和常量存储在此区域- 示例：`static int x;` |
| 2    | 栈上分配       | - 分配时机：在函数调用时分配- 生存周期：随函数调用结束自动释放- 典型用途：函数的局部变量、函数参数- 示例：`int x = 10;` |
| 3    | 堆上分配       | - 分配时机：程序运行时手动分配和释放内存- 生存周期：程序员控制，直到显式释放为止- 典型用途：动态内存分配- 示例：使用 `malloc`、`calloc` 或 `realloc` 分配内存，释放用 `free` |

### 静态存储区、栈、堆的属性对比表

| 属性     | 静态存储区           | 栈                       | 堆                                   |
| -------- | -------------------- | ------------------------ | ------------------------------------ |
| 分配时机 | 编译时               | 运行时，函数调用时       | 运行时，显式调用动态分配函数         |
| 生存周期 | 程序整个生命周期     | 函数作用域               | 程序员控制                           |
| 优点     | 高效，无需手动管理   | 分配与释放自动化，高效   | 灵活，适合动态需求                   |
| 缺点     | 占用固定内存，不灵活 | 容量有限（受栈空间限制） | 分配和释放管理复杂，可能引发内存泄漏 |
| 典型用途 | 全局变量、静态变量   | 局部变量、函数参数       | 动态数组、动态数据结构               |

## 堆和栈有什么区别

1. **申请方式**：栈的空间由操作系统自动分配 / 释放，堆的空间由程序员手动分配释放。
2. **申请大小的限制**：栈空间有限（Windows 下通常 1M 或 2M），超过会栈溢出；堆是大的自由存储区，大小取决于系统虚拟内存，空间灵活且较大。
3. **申请效率**：栈由系统自动分配，速度较快但程序员无法控制；堆由`new`等分配，速度较慢且易产生内存碎片，但使用灵活。

### 堆和栈的区别维度对比表

| 区别维度     | 栈                                                           | 堆                                                           |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 申请方式     | - 系统自动分配和释放- 无需程序员干预，简单高效               | - 由程序员手动分配和释放（使用`malloc`、`calloc`、`realloc`等）- 若未释放，会导致内存泄漏 |
| 空间大小限制 | - 容量有限：通常由系统设置，典型大小为 1M 或 2M（Windows）- 超过会引发栈溢出（stack overflow） | - 容量较大：取决于系统可用虚拟内存，通常远大于栈- 适合大对象或动态分配需求 |
| 地址方向     | - 向低地址扩展：内存从高地址向低地址增长                     | - 向高地址扩展：内存从低地址向高地址增长                     |
| 内存结构     | - 连续的内存区域，分配效率高                                 | - 不连续的内存区域，系统通过链表管理自由存储区，分配效率相对较低 |
| 存储内容     | - 存储局部变量、函数调用信息（返回地址、参数、临时变量等）   | - 存储动态分配的内存块，如动态数组、动态对象等               |
| 生存周期     | - 由函数的生命周期决定，函数退出时自动释放                   | - 由程序员控制生存周期，需手动释放内存                       |
| 申请效率     | - 分配速度快，开销小                                         | - 分配速度慢，开销大，容易产生内存碎片                       |
| 典型用途     | - 局部变量、函数参数                                         | \- 动态数组、动态数据结构                                    |

**栈内存分配的特点：**

- 因为是连续的内存块，所以访问速度快，开销低。
- 栈的生命周期由作用域控制，当作用域结束时，栈上的内存会被自动回收。

- 栈适用于临时变量或较小的数据结构的存储。

**堆内存分配的特点：**

- 堆是由程序员控制分配和释放的，因此灵活性高。
- 堆适用于动态分配的大型数据结构或需要跨函数共享的数据。
- 如果程序员未能及时释放内存，可能引发内存泄漏。

### 补充：RTOS 中任务相关概念

**任务 TASK 是一个运行的函数，为什么这么说？**

RTOS 中的任务是运行在**多任务环境**中的，每个任务就是一个线程。任务运行和调度由 RTOS 内核管理，任务可以拥有不同的优先级。

在 RTOS 中，任务本质上是一个 C 函数。这个函数通常是由`xTaskCreate()`创建任务时指定的。RTOS 会为任务分配一块内存，用来保存任务的上下文信息，包括其堆栈、寄存器状态等。

**为什么任务要保存寄存器？**

任务是一个独立的执行单元，在多任务操作系统中，多个任务共享一个处理器。为了保证任务切换后能够恢复到正确的执行状态，需要保存当前任务的 CPU 寄存器值，包括：

- 程序计数器（PC）：指向当前执行位置。
- 堆栈指针（SP）：指向任务栈的当前位置。
- 通用寄存器：用于存储任务执行中的临时数据。
- 状态寄存器：保存中断和任务的状态信息。

任务的栈中不仅保存了任务函数的局部变量，还保存了任务切换时的寄存器值。因此，不同于普通函数调用，任务函数的栈不仅用于存储局部变量，还要保存任务切换时的上下文。

从汇编的角度来看，任务的上下文切换涉及到保存和恢复 CPU 寄存器的过程：

- **任务切换过程**：当任务切换时，FreeRTOS 会通过汇编指令（通常是`push`和`pop`指令）保存当前任务的寄存器状态到任务的堆栈上，并恢复下一个任务的寄存器状态。任务的堆栈空间因此在上下文切换过程中发挥了重要作用。

#### 典型的任务上下文切换流程：

1. 在任务 A 执行时，任务 A 的寄存器值会被保存在任务 A 的栈中。
2. 如果任务 A 被挂起，FreeRTOS 会选择任务 B 来执行，在切换到任务 B 时，FreeRTOS 会从任务 B 的栈中恢复其寄存器值，从而恢复任务 B 的执行状态。
3. 任务 A 的寄存器状态被恢复时，任务 A 继续从它的上次执行位置恢复执行。

这种上下文切换是由 FreeRTOS 内核的调度程序管理的。内核提供了对上下文切换的支持，具体实现依赖于目标架构的汇编代码。



## 压栈顺序

C语言参数采用自右向左的入栈顺序，主要是为了支持可变长参数形式。

**为什么是从右至左**

1. **支持可变长参数**：C 语言中函数可接受不同数量的参数（例如`printf`函数）。从右至左入栈时，最右边的参数会被优先压入栈中，便于从最后一个参数开始逐步向左处理可变参数列表，与栈操作顺序匹配。
2. **便于参数访问**：压栈顺序决定了通过栈指针（SP）访问参数的方式。右至左压栈时，最后一个参数位于栈的最低地址，调用者可通过调整栈指针正确访问各个参数。
3. **递归和多层函数调用支持**：右至左的压栈顺序能在递归调用中正确管理栈空间，避免动态变化的参数个数带来的混乱。

```c
void exampleFunction(int a, float b, double c);
```

以 `exampleFunction(1, 2.5, 3.14)`（参数 `a=1`、`b=2.5`、`c=3.14`）为例：

#### 1. 正确的压栈流程（右至左）

1. 第一步：压入最右侧参数 `c`（double 类型，8 字节）

  这是第一个入栈的参数，存入后位于栈顶（地址最低，最靠近栈的生长方向末端）。

2. 第二步：压入中间参数 `b`（float 类型，4 字节） 

  这是第二个入栈的参数，地址比`c`更高（更远离栈顶，靠近栈底）。

3. 第三步：压入最左侧参数 `a`（int 类型，4 字节）

  这是最后一个入栈的参数，地址最高（最靠近栈底）。


#### 2. 正确的栈结构示意（x86 架构，栈向低地址生长）

| 地址高低        | 栈内容                | 说明               |
| --------------- | --------------------- | ------------------ |
| 高地址（栈底）  | a (int，值 = 1)       | 最后入栈，地址最高 |
| ↓（栈向下生长） | b (float，值 = 2.5)   | 中间入栈，地址中等 |
| 低地址（栈顶）  | c (double，值 = 3.14) | 最先入栈，地址最低 |



## 内存管理

在C++中“虚拟内存分区”的划分主要为“代码段、数据段、BSS段、堆、栈”

- **代码段（Text Segment）**：包括**只读存储区和文本区**，其中制度存储区存储**字符串常量**，文本区存储程序的机器代码。
- **数据段（Data Segment）**：存储程序中**已初始化**的全局变量和静态变量。
- **BSS段（Block Started by Symbol）**：存储**未初始化的全局变量   和 （全局+局部（未初始化））静态变量，以及所有被初始化为0的全局变量和静态变量。**
- **堆区(Heap)：**调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。
- **栈区(Stack)：**使用栈空间存储函数的返回地址、参数、局部变量、返回值。



## 内存泄露

### 如何检测与预防内存泄漏？

内存泄漏的处理分为**预防**和**检测**两类方式：

#### 一、预防内存泄漏的方法

1. **规范内存操作习惯**
   - 内存分配与释放一一对应：使用 `malloc`/`new` 分配内存后，必须通过 `free`/`delete`（数组用 `delete[]`）释放；避免 “分配后未释放”“重复释放”“释放非动态分配内存”。
   - 采用 RAII 思想：通过**对象的构造 / 析构**管理资源（如动态内存），确保资源在对象生命周期结束时自动释放（例如 C++ 标准库的智能指针、自定义资源管理类）。

**使用智能指针（C++）**C++11 及以后的**标准库智能指针**可自动管理动态内存，避免手动释放的遗漏：

- `std::unique_ptr`：独占式智能指针，同一内存仅一个所有者，作用域结束时自动释放内存。
- `std::shared_ptr`：共享式智能指针，通过引用计数管理内存，当引用计数为 0 时自动释放。

```cpp
#include <memory>
// unique_ptr 示例
std::unique_ptr<int> up = std::make_unique<int>(10); 
// shared_ptr 示例
std::shared_ptr<int> sp = std::make_shared<int>(20);
```

**自定义内存跟踪工具**通过数据结构（如链表）跟踪所有动态分配的内存指针：

- 分配内存时，将指针加入链表；释放内存时，从链表中移除。
- 程序结束前检查链表：若链表非空，则存在未释放的内存（即内存泄漏）。

```c++
#include <cstddef>
//链表节点结构体，存储动态内存地址（ptr）和下一个节点指针（next）
struct MemoryNode {
    void* ptr;
    MemoryNode* next;
};
//全局链表头指针，用于管理所有已分配未释放的内存地址，初始化为nullptr
MemoryNode* g_memoryList = nullptr;

// 内存分配后调用，将内存地址封装为链表节点，加入全局链表（实现内存跟踪）
void trackMalloc(void* ptr) {
    MemoryNode* node = new MemoryNode{ptr, g_memoryList};
    g_memoryList = node;
}

// 内存释放后调用，从全局链表中移除对应内存地址的节点（取消内存跟踪）
void untrackFree(void* ptr) {
    MemoryNode *curr = g_memoryList, *prev = nullptr;
    while (curr != nullptr && curr->ptr != ptr) {
        prev = curr;
        curr = curr->next;
    }
    if (curr != nullptr) {
        (prev ? prev->next : g_memoryList) = curr->next;
        delete curr;
    }
}
```



#### 二、检测内存泄漏的工具

通过专业工具可高效定位内存泄漏：

- **Valgrind memcheck**（Linux）：动态分析工具，可检测内存泄漏、越界访问等问题。
- **AddressSanitizer（ASAN）**（跨平台）：编译器内置工具，能快速检测内存泄漏、使用已释放内存等问题。
- **Visual Leak Detector（VLD）**（Windows）：Visual Studio 插件，用于检测 C/C++ 程序的内存泄漏。