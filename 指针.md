## 1. 指针的本质

### 1.1 指针是什么？

- **指针的本质是一个内存地址**，它表示某个数据在内存中的位置。
- 在底层，指针只是一个数值（例如 `0x1000`），表示内存中的某个地址。

### 1.2 示例代码

```c
#include <stdio.h>

int main() {
    int x = 10;
    int *p = &x;  // p 存储的是变量 x 的内存地址

    printf("x 的值: %d\n", x);
    printf("x 的地址: %p\n", (void*)p);

    return 0;
}
```

**输出：**

```x86asm
x 的值: 10
x 的地址: 0x7ffee4b5c9a4
```

------

## 2. 指针的类型

### 2.1 类型的意义

- **类型是编译器提供的抽象**，它告诉编译器如何解释指针指向的内存中的数据。
- 类型还决定了指针运算的行为。

### 2.2 示例代码

```c
#include <stdio.h>

int main() {
    int arr[3] = {10, 20, 30};
    int *p = arr;  // p 指向数组的第一个元素

    printf("p 的值: %p\n", (void*)p);
    printf("p + 1 的值: %p\n", (void*)(p + 1));  // p + 1 指向数组的第二个元素

    return 0;
}
```

**输出：**

```less
p 的值: 0x7ffee4b5c9a0
p + 1 的值: 0x7ffee4b5c9a4
```

- `p + 1` 的值增加了 `4`，因为 `int` 类型的大小是 `4` 字节。

------

## 3. 强制类型转换

### 3.1 强制类型转换的意义

- 强制类型转换只是告诉编译器：**将指针视为另一种类型**。
- 它不会改变指针的值（即内存地址），也不会改变内存中存储的数据。

### 3.2 示例代码

```c
#include <stdio.h>

int main() {
    int x = 10;
    int *p = &x;
    char *q = (char*)p;  // 将 int* 强制转换为 char*

    printf("p 的值: %p\n", (void*)p);
    printf("q 的值: %p\n", (void*)q);

    return 0;
}
```

**输出：**

```less
p 的值: 0x7ffee4b5c9a4
q 的值: 0x7ffee4b5c9a4
```

 p和q的值相同，但它们的类型不同：

- `p` 是 `int*` 类型，表示指向 `int` 类型的指针。
- `q` 是 `char*` 类型，表示指向 `char` 类型的指针。

### 3.3 指针强制转换的5大规则

1. **指针类型互相转换不改变数值，只改变解释方式**
2. **不同对象类型的指针转换是允许的，但可能违反对齐要求**
3. **只有 void\* 是通用指针，可以隐式转换，但函数指针不行（重要！）**
4. **指针 → 整数 必须使用<stdint.h>中的 uintptr_t / intptr_t（标准安全）**
5. **整数 → 指针 允许，但必须保证地址合法**

------

## 4. 复杂指针转换的例子

### 4.1 复杂指针转换

- 复杂指针转换（如 `int s = (int)(char*)p;`）涉及多级指针和类型转换。
- 这种转换通常用于底层编程或特殊场景。

### 4.2 示例代码

```c
#include <stdio.h>

int main() {
    int ****p = (int****)10;  // p 是一个四级指针，指向内存地址 10
    int s = (int)(char*)p;    // 将 p 转换为 char*，再转换为 int

    printf("p 的值: %p\n", (void*)p);
    printf("s 的值: %d\n", s);

    return 0;
}
```

**输出：**

```css
warning: cast from pointer to integer of different size [-Wpointer-to-int-cast]
     int s = (int)(char*)p;    // 将 p 转换为 char*，再转换为 int
             ^
p 的值: 000000000000000A
s 的值: 10
```

- `p` 的值是 `10`，表示它指向内存地址 `10`。
- `(char*)p` 将 `p` 转换为 `char*` 类型的指针，值仍然是 `10`。
- `(int)(char*)p` 将 `char*` 类型的指针的值（即内存地址 `10`）转换为整数 `10`。
- 编译器警告原因：

  - 指针在 x64 上是 **8 字节**
  - `int` 是 **4 字节**

  你把一个 64 位的值塞回一个 32 位的变量，会发生 **截断**。

  比如如果地址是 `0x1234567890ABCDEF`，你强转成 int 后会变成：

  ```
  0x90ABCDEF
  ```

  会丢掉高 32 位。

### 4.3 四级指针是什么

`int ****p` 只是表示“指向指向指向指向 int 的指针的指针的指针”。

但核心事实：

无论你几级指针，本质都是一个**整数**（地址值）。

 级数只是告诉**编译器**“这个地址里的内存如何解释“ 。

------

## 1. 指针数组和数组指针

### 1.1 什么是指针数组和数组指针

- 指针数组：指针数组可以说成是“指针的数组”，首先这个变量是一个**数组**，其次，“指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型。

  [^在32位系统中，指针占四个字节，在64位系统中，所有指针的大小都是8字节]: 

- 数组指针：数组指针可以说成是“数组的指针”，首先这个变量是一个**指针**，其次，“数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。

- 两者是两种类型的变量。

### 1.2 指针数组和数组指针的详解

#### 1.2.1 指针数组

定义一个指针**数组**，因为是数组，名字就叫arr。

```
char *arr[4] = {"zhi","zhen","shu","zu"};
//arr就是一个指针数组，它有四个元素，每个元素都是一个char *类型的指针，这些指针存放着对应字符串的首地址。
```

```c
#include <stdio.h>

int main() {
   
    char *arr[4] = {"zhi", "zhen", "shu", "zu"};
    printf("指针数组的第一个的值：%p\n", arr[0]);
    printf("指针数组的第一个的指向的地址的值：%s\n", arr[0]);
    printf("%c\n", *(p_arr[1] + 1));
    return 0;
}

```

输出:

```
指针数组的第一个的值：0000000000404000 //数组中包含的是指针
指针数组的第一个的指向的地址的值：zhi    //指针指向的内容才是“zhi”
e                                 //p_arr[1]指向"def"，+1指向'd'的下一个字符'e'
```

这个指针数组在64位系统中有4*8 = 32字节，因为一个指针为8个字节

当有对变量所占空间有疑惑时，要反应出**内存映像图**

| 内存映像像图            | 核心属性（读写/权限）          | 存储内容                                                     | 关键特征                                                     |
| ----------------------- | ------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 命令行参数 / 环境变量区 | 只读（环境变量）/ 可读（参数） | `main` 函数的 `argc`/`argv`（命令行参数）、环境变量（如 `PATH`） | 位于栈区上方、程序启动时由操作系统传入、只读属性（部分系统可修改） |
| 栈区（Stack）           | 可读可写                       | 函数局部变量（如 `int a = 5;`）、函数参数、返回值、栈帧信息（保存上下文） | 自动管理（函数调用时压栈、返回时弹栈）、大小固定（超出会栈溢出）、地址从高向低增长 |
| 堆区（Heap）            | 可读可写                       | 动态分配的内存（`malloc`/`calloc`/`realloc` 分配的空间、C++ 中 `new` 分配的空间） | 大小动态变化（运行时申请 / 释放）、由程序员手动管理（漏释放会内存泄漏）、地址从低向高增长 |
| BSS 段（.bss）          | 可读可写                       | 未初始化的全局变量（如 `int g_uninit;`）、未初始化的静态变量（如 `static int s_uninit;`） | 编译时仅分配地址（不占磁盘空间）、程序启动时由操作系统清零、大小运行前确定 |
| 数据段（.data）         | 可读可写                       | 已初始化的全局变量（如 `int g_val = 10;`）、已初始化的静态变量（如 `static int s_val = 20;`） | 编译时确定大小、程序启动时由操作系统加载初始化值、生命周期贯穿整个程序 |
| 只读数据段（.rodata）   | 只读（不可写）                 | 字符串字面量（如 `"hello"`）、`const` 修饰的全局 / 静态只读变量、字面常量（如 `3.14`） | 编译时确定大小、不可修改（强行写会触发段错误）、有时被归为代码段附属 |
| 代码段（.text）         | 只读（不可写）                 | 编译后的机器指令（函数体代码、流程控制指令等）               | 固定大小（编译时确定）、共享（多个进程可共享同一份代码）、高地址起始 |

- **堆和栈的增长方向**：多数系统中，栈从高地址向低地址 “向下增长”，堆从低地址向高地址 “向上增长”，两者之间有空闲区域（避免冲突）。
- **const 变量的特殊情况**：`const` 修饰的局部变量（如 `void func() { const int a = 1; }`）实际存在栈区（只是编译时禁止修改），只有全局 / 静态 `const` 变量才在 `.rodata` 段。

#### 1.2.2 数组指针

定义一个数组**指针**，变量是指针，就叫做p_arr

```
char (*p_arr)[4];
```

Q:既然p_arr是一个指针，存放一个数组的地址，那么在我们定义一个数组时，数组名称就是这个数组的首地址，那么这二者有什么区别呢？能相互赋值吗？

A：例如`char a[4]; `,a是一个长度为4的字符数组，a是**“数组类型标识符”，在表达式中隐式转换为数组的首元素的地址**。既然a是地址，p_arr是**指向整个数组的指针**，不能互相赋值，因为a是**数组首元素**首地址，p_arr存放的是**数组**首地址，a是char类型，`a+1`,a的值会加一，而p_arr是char[4]类型的，`p_arr+1`，p_arr则会加4，两者操作不同，类型不匹配不能直接赋值。

```c
#include <stdio.h>

int main() {
   
    char a[4];
    char *p_elem = a;
    char (*p_whole_arr)[4] = &a;
	/*
	p_whole_arr = a;        // 编译报错！a隐式转char*，和p_whole_arr的char(*)[4]类型不匹配
	p_whole_arr = &a;       // 合法！&a是“整个数组的地址”，类型正是char(*)[4]，直接匹配
	*/
    
    printf("a的地址：%p\n", a);      // 首元素地址
    printf("a+1的地址：%p\n", a+1);  // 偏移1字节，char类型大小是1
    printf("p_elem+1：%p\n", p_elem+1);  // 和a+1完全一致
    printf("\n");
   
    printf("&a的地址：%p\n", &a);        // 数值还是和a的数值相同
    printf("p_whole_arr+1：%p\n", p_whole_arr+1);  // 输出偏移4字节，数组类型大小是4
    return 0;
}
```

输出：

```
a的地址：000000000061FE0C
a+1的地址：000000000061FE0D
p_elem+1：000000000061FE0D

&a的地址：000000000061FE0C
p_whole_arr+1：000000000061FE10
```

### 1.3 指针数组和数组指针的使用

#### 1.3.1 指针数组的使用

指针数组是「**管理多个字符串**」的最优方案（比二维字符数组`char arr[4][5]`更灵活、省空间），核心用法如下：

```
// 冒泡排序：按字符串字典序排序（升序）
void sort_strings(char *p_arr[], int n) {
    char *tmp;
    for (int i = 0; i < n-1; i++) {
        for (int j = 0; j < n-1-i; j++) {
            // strcmp比较两个指针指向的字符串内容
            if (strcmp(p_arr[j], p_arr[j+1]) > 0) {
                // 交换指针（仅8字节，比拷贝字符串快得多）
                tmp = p_arr[j];
                p_arr[j] = p_arr[j+1];
                p_arr[j+1] = tmp;
            }
        }
    }
}
```

在排序时无需拷贝字符串内容（仅交换指针），效率较高（尤其字符串比较长的时候）。

#### 1.3.2 数组指针的使用

数组指针专门用于「**指向完整数组**」，而非单个元素，字符场景下用得较少（多在二维数组传参、操作固定长度字符数组时使用）。

二维数组传参时，数组名会隐转为「指向一维数组的指针」（即数组指针），用数组指针接收能明确数组维度，更严谨

### 1.4 巩固理解

1.以下代码输出什么？为什么？

```c
char *p_arr[] = {"abc", "def", "ghi"};
printf("%c\n", *(p_arr[1] + 1)); // 输出 'e'（p_arr[1]指向"def"，+1指向'd'的下一个字符'e'）
```

2.以下代码编译报错吗？为什么？

```c
char arr[5] = "test";
char (*arr_p)[5] = arr; // 报错！arr隐转为char*，与arr_p的char(*)[5]类型不匹配，需改为&arr
```

3.字符指针数组和二维字符数组（`char arr[3][5]`）的区别？

- 字符指针数组：元素是指针，指向的字符串长度可不同，省空间，排序高效；
- 二维字符数组：元素是字符，每行长度固定，浪费空间，排序需拷贝字符内容。



## 函数指针和指针函数

### 函数指针

**函数指针**是一个指针，指向函数的地址。它允许通过指针调用函数

声明方式如下：

```c
return_type (*pointer_name)(parameter_list);
```

本质：存储的是函数的入口地址

```c
#include<stdio.h>

void Send_Message(const char* Message){
    printf("%s\n",Message);
}

int main(){
    void (*Func)(const char*);//函数内变量类型必须相同
    Func = Send_Message;
    Func("Hello");
    return 0;
}

[Running] cd "d:\C\" && gcc study.c -o study && "d:\C\"study
Hello
```

### 指针函数

**指针函数**是一个函数，返回值是一个指针。

声明方式如下：

```c
return_type *function_name(parameter_list);
```



## 指针常量、常量指针、指向常量的常量指针

核心：**「const 修饰的是谁，谁就不可被修改」**

### 指针常量

标准写法 & 语法格式

```c
数据类型 *const 指针变量名
```

**指针本身是「常量」** → 指针存储的**地址不可修改**（一旦指向某个内存，就永远不能指向其他内存）；

 **指针指向的目标是「变量」** → 可以通过指针**自由修改目标内存的数据**。

### 常量指针

标准写法 & 语法格式

```c
// 格式1（推荐，可读性最强）
const 数据类型 * 指针变量名;
// 格式2（等价写法，const位置不同，含义完全一致）
数据类型 const * 指针变量名;
```

是指**指针本身的值不可变**，但是指针指向的内容是可以变的：

```
#include <stdio.h>
int main(){
	int a = 10, b = 20;
    const int *p = &a; // 常量指针：指向a，const在*左侧
	p = &b; //合法（就是可以更改指向的内容的值）
	// ✅ 合法操作1：修改指针本身的地址（指针可变，指向其他变量）
	 *p = 30; // 编译器报错：assignment of read-only location '*p'
	 // ❌ 非法操作1：通过指针修改目标值（目标是常量，不可改）
	 return 0；
}
```

### 指向常量的常量指针

标准写法 & 语法格式

```c
// 固定格式：两个const，分别修饰「目标值」和「指针地址」
const 数据类型 * const 指针变量名;
```

- 第一个`const`（`*`左侧）：修饰「指针指向的目标」→ 目标值不可改；
- 第二个`const`（`*`右侧）：修饰「指针本身」→ 指针地址不可改。

## 5. 相关函数的编写

### 5.1 strlen 函数

```
#include <stdio.h>

int my_strlen(const char *str) {
    int len = 0;
    while (*str != '\0') { // 遍历到字符串结束
        str++;
        len++;
    }
    return len;
}
```

### 5.2 swap函数

```
void swap(int *a, int *b){
    int c = *a;
    *a = *b;
    *b = c;
}
```

### 5.3 二级指针分配二维数组

```
int **arr;
int m = 3, n = 4;

// 分配行指针
arr = (int **)malloc(m * sizeof(int*));

// 分配每一行
for(int i = 0; i < m; i++){
    arr[i] = (int *)malloc(n * sizeof(int));
}

// 使用
arr[0][0] = 1;

// 释放内存
for(int i = 0; i < m; i++){
    free(arr[i]);
}
free(arr);

```

- 二维数组动态分配（`int **arr`）时，**要 free 两层**。
- **并不是分配了一整块连续的二维数组**，而是分配了：
  1. 一个“行指针数组”（`int*` 的数组）
  2. `m` 个独立的“每一行的数据”

内存结构是这样的：

```scss
arr  ──► [ ptr0 ][ ptr1 ][ ptr2 ] ... [ ptr(m-1) ]
            │       │       │
            ▼       ▼       ▼
          row0    row1    row2   ...  row(m-1)
```

#### ① 释放每一行的数据

因为每一行都是单独 malloc 出来的：

```
for(int i = 0; i < m; i++){
    free(arr[i]);   // 释放每一行
}
```

如果你不 free 这一层，**每行的数据会泄漏**。

------

#### ② 再释放行指针数组

最后再 free 第一层：

```
free(arr);
```

如果你不 free 这一层，**整个指针表本身会泄漏**。

## 6. 常见问题与解答

### 6.1 指针中int* 和 int *的区别

- 在语法和意义上没有**任何区别**，完全一样
- 真正有意义的差别——多变量定义！

```
int* a, b;
```

这行代码不会定义两个指针，而是：

- `a` 是 `int*`
- `b` 是 `int`

为什么？因为 `*` 只作用在紧挨着的变量名 `a` 上。

等价于：

```
int *a;
int b;
```

推荐将 `*` 靠近变量名，因为指针是变量的属性：

```
int *a, *b, c;
```

否则会造成误解。

### 6.2 为什么指针的大小与类型无关？

- 在64位系统中，所有指针的大小都是8字节，因为地址总线宽度是64位。
- 类型只是编译器提供的抽象，用于解释指针指向的内存中的数据。

### 6.3 强制类型转换会改变指针的值吗？

- **不会**。强制类型转换只是改变编译器对指针的解释方式，而不会改变指针的值或内存中存储的数据。

### 6.4 指针运算的偏移量如何计算？

- 指针运算的偏移量由指针的类型决定。例如：
  - `int *p`：`p + 1` 增加 `sizeof(int)`。
  - `char *p`：`p + 1` 增加 `sizeof(char)`。

------

## 7. 总结

- **指针的本质是一个内存地址**，在底层没有任何类型信息。
- **类型是编译器提供的抽象**，它告诉编译器如何解释指针指向的内存中的数据。
- **强制类型转换**只是改变编译器对指针的解释方式，而不会改变指针的值或内存中存储的数据。