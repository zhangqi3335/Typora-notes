## 1. 结构体内存对齐

### 1.1 为什么结构体会占用比你想象更多的空间

CPU 访问内存时：

- 1字节对齐：效率最低
- 2，4，8字节对齐：效率更高（STM32 Cortex-M 通常是4字节对齐）
- 编译器默认会按结构体里**最大成员对齐**。

例如：结构体Frame_t的大小

```c
typedef struct {
    uint8_t header;       // 1 字节
    uint16_t temperature; // 2 字节
    float humidity;       // 4 字节
    uint8_t crc;          // 1 字节
} Frame_t;
```

1. `header`是`uint8_t`（1字节），放在offset 0 ：占用`A+0` 。
  - 下一个成员`uint8_t`(2字节对齐),因此`uint16_t`必须放在能被2整除的地址。
  - `A+1`不是偶数地址(相较于A),所以编辑器在`header`后插入一个字节的填充(padding)使下一个成员从`A+2`开始。
  - 所以`header`实际占用`A+0`,padding占用`A+1`。
2. `temperature`（`uint16_t`）放在 offset 2：占 `A+2` 和 `A+3`（共 2 字节）。
3. 下一个是 `float`（4 字节对齐）。当前下一个可用地址是 `A+4`（因为 `temperature` 用到 `A+3`），`A+4` 能被 4 整除 → 已满足 `float` 的 4 字节对齐。
  - `humidity` 放在 `A+4`..`A+7`（4 字节）。
4. `crc`（uint8_t）放在 `A+8`（offset = 8）。`crc` 占 `A+8`（1 字节）。

- 之后没有成员了，但**结构体整体也必须满足对齐约束**（结构体的对齐通常等于其**最大成员的对齐**，即 4 字节）。因此结构体的大小必须是 4 的倍数。

- 当前最后使用的字节索引是 `A+8`（第 9 字节），总长度 9 字节。为了使整个结构体大小为 4 的倍数，需要在结构体末尾补 **3 个字节的尾部填充（tail padding）**。

- 因此 `sizeof(Frame_t)` = 12 字节。

### 1.2 `offset`(偏移量) 是什么意思？

- **offset = 0** 表示成员从**结构体起始地址**（假设为地址A）开始的第0字节处；
- offset = 4 表示成员在`A+4`的位置（第四个字节）；
- 在布局中用offset 标注每个成员在结构体里的位置。

### 1.3 为什么要有`padding` (填充字节)？

- **目标：提高内存访问效率与满足硬件/ABI 要求。**CPU在读取多字节数据（如2字节，4字节）时，通常在“对齐地址”上效率最高（或是必须）。编译器会在成员前面插入填充，使该成员的地址满足对齐要求。
- 例如`uint16_t`一般需要2字节对齐：它的地址必须是偶数（能被2整除）；`float`一般需要4字节对齐：地址能被4整除。
- 这些对齐规则由平台的**ABI（Application Binary Interface）**规定。

### 1.4 为什么要有`tail padding`（结构体末尾的填充）？

- 如果没有尾部填充，那么把结构体数组放在内存中时，后一个元素的起始地址可能导致前一个元素内部的成员不再对齐。尾部填充保证数组元素之间的距离是结构体对齐的倍数，从而维护所有成员对齐。

**内存字节图**（以地址A起始，显示每字节）

写成 `A+0  A+1  A+2  A+3  A+4  A+5  A+6  A+7  A+8  A+9  A+10 A+11`

```less
A+0: header
A+1: padding (between header and temperature)
A+2: temperature low byte
A+3: temperature high byte
A+4: humidity byte 0 (float, little-endian lowest byte)
A+5: humidity byte 1
A+6: humidity byte 2
A+7: humidity byte 3
A+8: crc
A+9: tail padding
A+10: tail padding
A+11: tail padding
```

### 1.5 常见提醒

#### 1.5.1 通信协议里常用

- **使用 `__attribute__((packed))` 会把结构体紧凑排列**（`sizeof` 变为 8），但在某些平台上访问未对齐的 `uint16_t`/`float` 可能会导致：
  - 性能下降（需要多次内存访问或软件合成），或
  - 在某些架构上发生硬件异常（例如某些老架构会产生总线错误）。
  - Cortex-M（ARM）通常能处理非对齐访问，但可能性能较差或在某些配置下有陷阱；所以常在通信协议的“字节流”上使用 packed，但在内存中处理时有时先 memcpy 到本地对齐变量再访问更安全。

- **通信协议里常用 `packed`**（因为协议是按字节流定义的），但要注意**字节序（endianness）**：`uint16_t` 在发送时要显式按小端/大端拆字发送，float 也通常用 `memcpy`到字节数组再发送以避免实现差异。

- **推荐做法**：
  - 协议定义用 `packed` 的“传输结构体”或手写 pack/unpack 函数（明确字节序）。
  - 内部处理尽量使用按自然对齐的本地结构，或在访问前 `memcpy` 到局部对齐变量（避免未对齐直接访问）。